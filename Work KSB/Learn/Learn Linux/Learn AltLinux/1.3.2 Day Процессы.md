#learn #linux #alt #bash
1. Запустите в фоновом режиме два задания: sleep 200 и sleep 2000, выведите информацию о состоянии заданий.
Команда:
``` sh
sleep 200 &
sleep 2000 &
jobs
```
- Описание:
	- `sleep 200 &`: Запускает процесс "спящего" состояния на 200 секунд в фоновом режиме.
	- `sleep 2000 &:` Запускает процесс "спящего" состояния на 2000 секунд в фоновом режиме.
	- `jobs`: Выводит информацию о заданиях, включая их состояние и идентификаторы.

2. Снимите с выполнения 2-е задание, выведите информацию о заданиях.

Команда:
```sh
kill %2
jobs
jobs
```
- Описание:
	- `kill %2:` Отправляет сигнал завершения процессу с идентификатором 2 (второму запущенному заданию).
	- `jobs`: Выводит информацию о заданиях, чтобы убедиться, что второе задание завершено.

3. Как изменяется общая картина жизненного цикла процесса в системе по сравнению с описанным, если процесс запускается в фоновом режиме.
	- При запуске процесса в фоновом режиме, он продолжает выполняться в фоне, не блокируя терминал. Пользователь может продолжать работу с командной строкой, в то время как процесс выполняется. Пользователь может отправлять сигналы процессу или прервать его выполнение.

4. Выполните команду exec ls. Изучите ее поведение.
Команда:
```sh
exec ls
```
- Описание:
	- `exec`: Заменяет текущий процесс новым процессом, указанным в аргументах командной строки.
	- `ls`: Команда для вывода содержимого текущего каталога.
	- Команда `exec ls` заменит текущий процесс процессом **ls**, поэтому после выполнения этой команды вместо оболочки Bash будет запущена утилита **ls**, и после её завершения пользователь снова вернется в оболочку Bash.

5.Получите информацию о процессах в обычном и подробном форматах.

Команда:
```sh
ps
ps aux
```

- Описание:
	- `ps`: Выводит список текущих процессов в обычном формате.
	- `ps aux`: Выводит список всех процессов в подробном формате, включая процессы всех пользователей.

6. Выведите список всех процессов, запущенных всеми пользователями, вошедшими в сеанс, в системе.

Команда:
```sh
ps -e
```

- Описание:
	- `ps -e`: Выводит список всех процессов, запущенных на системе.

7. Проследите в течение минуты поведение процессов, использующих наибольшее процессорное время, используя наиболее подходящую для этого утилиту.

Команда:
```sh
top
```

- Описание:
	- Утилита top показывает текущие процессы, использующие наибольшее процессорное время, а также другую информацию о загрузке системы. Обновляется периодически и позволяет отслеживать изменения в реальном времени.

8.Получите иерархический список процессов с помощью команды ps.

Команда:
```sh
ps axjf
```

- Описание:
	- `ps axjf`: Выводит иерархический список процессов в виде дерева.

9.Запустите порожденную оболочку Bash. Исследуйте, посылая родительской оболочке Bash сигналы TERM, INT, QUIT и HUP, что при этом происходит.

Команда:
```sh
bash
```
- Описание:
	- Запускает новую оболочку Bash. При посылке сигналов родительской оболочке:
	- SIGTERM (15): Обычно приводит к завершению процесса.
	- SIGINT (2): Прерывает процесс (аналогично нажатию Ctrl+C).
	- SIGQUIT (3): Приводит к корректному завершению процесса с созданием core dump.
	- SIGHUP (1): Обычно используется для перезапуска процесса.

10. От имени обычного пользователя пошлите сигнал KILL любому процессу, запущенному от имени другого пользователя. Что произойдет?

Команда:
```sh
kill -9 <PID>
```

- Описание:
	- `kill -9 <PID>`: Отправляет сигнал KILL (9) процессу с указанным идентификатором.
	Процесс будет насильственно завершен, даже если он будет запущен от имени другого пользователя. Это происходит потому, что сигнал KILL не может быть перехвачен или обработан процессом, и он немедленно завершает процесс, игнорируя все другие обстоятельства.

11. Запустите в фоновом режиме команду sleep 1000. Проверьте, на какие сигналы из следующих: TERM, INT, QUIT и HUP, реагирует эта команда.

Команда:
```sh
sleep 1000 &
```

- Описание:
	Команда sleep 1000 & запускает процесс "спящего" состояния на 1000 секунд в фоновом режиме.
	
	Реакция на различные сигналы:
	
	SIGTERM (15): Процесс будет завершен.
	SIGINT (2): Процесс будет прерван.
	SIGQUIT (3): Процесс будет завершен, создав core dump.
	SIGHUP (1): Поведение зависит от настройки терминала. Обычно процесс будет прерван, если он связан с терминалом.